---
sidebar: 'auto'
prev: /zh/harvest/overview.md
next: /zh/harvest/mysql/lock.md

---

# 索引原理及原则

::: tip
`索引` 本质上是一种数据结构，符合特定的算法，维护了数据表字段与查寻条件之间的关系。
:::

## 索引分类

- 数据结构角度: `B-TREE`、`HASH`、`FULLTEXT`、`R-TREE`
- 物理存储角度: 聚簇索引、非聚簇索引
- 按照逻辑角度: 主键索引、唯一索引、普通索引、组合索引、全文索引

### 索引与引擎对应关系

|   索引    |            InnoDb             |            MyISAAM            |            MEMORY             |
| :-------: | :---------------------------: | :---------------------------: | :---------------------------: |
|   BTREE   |      :white_check_mark:       |      :white_check_mark:       |      :white_check_mark:       |
|   HASH    | :negative_squared_cross_mark: | :negative_squared_cross_mark: |      :white_check_mark:       |
|   RTREE   | :negative_squared_cross_mark: |      :white_check_mark:       | :negative_squared_cross_mark: |
| FULL-TEXT |      :white_check_mark:       |      :white_check_mark:       | :negative_squared_cross_mark: |

---

## B-TREE

![](http://img.tzf-foryou.com/img/20220501181954.jpg)

---

> 持有的属性：
> 
> M: 子节点个数(本图中M=3)
> 
> N: 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1

---

模拟查找关键字29的过程:

1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

::: tip 【总结】
分析上面过程，发现需要3次磁盘 `I/O` 操作，和3次内存查找操作。
由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。
而3次磁盘 `I/O` 操作是影响整个 `B-Tree` 查找效率的决定因素。
`B-Tree` 相对于 `AVLTree缩` 减了节点个数，使每次磁盘 `I/O` 取到内存的数据都发挥了作用，从而提高了查询效率。
相比二叉搜索树，高度/深度更低，自然查询效率更高。
:::

## B+TREE

![](http://img.tzf-foryou.com/img/20220501183038.jpg)

---

**B+Tree相对于B-Tree有几点不同：**

- 非叶子节点只存储键值信息。
- 所有叶子节点之间都有一个链指针
- 数据记录都存放在叶子节点中

---

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点(即数据节点)之间是一种链式环结构。
因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
B+Tree的查询效率更加稳定。由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子，所以更稳定。

---

::: tip
从二叉查找树过渡到B树，有一个显著的变化就是，一个节点可以存储多个数据了，相当于一个磁盘块里边可以存储多个数据，大大减少了我们的 `I/O` 次数 !!!
:::

---

## HASH

![](http://img.tzf-foryou.com/img/20220501183528.jpg)

---

简单地说，***哈希索引就是采用一定的哈希算法***，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

---

### 和B-tree区别:

- 如果是***等值查询***，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据。
- 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索。
- 哈希索引也没办法利用索引完成排序，以及 `like 'xxx%'` 这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询)。
- 哈希索引也不支持多列联合索引的最左匹配规则。
- B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。
- 在MySQL中，只有 `HEAP/MEMORY` 引擎表才能显式支持哈希索引(NDB也支持，但这个不常用)

---

## 聚簇索引

将数据存储与索引放到了一块，找到索引也就找到了数据。操作是在内存里面，不用回行操作。详见: [聚簇索引](https://www.jianshu.com/p/fa8192853184)

---

## 非聚簇索引

![](http://img.tzf-foryou.com/img/20220501184329.png)

---

- InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用 `"where id = 14"` 这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。(重点在于通过其他键需要建立辅助索引)
- MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

---

## 主键索引

- 主键索引必定是唯一索引，但是唯一索引不一定是主键索引。
- 一张表只能有一个主键，不能为空。
- 用于快速索引，参考上面的 `聚簇索引` 中使用主键的操作。
- 常见用于外键约束。

---

## 唯一索引

- 可以起到约束列数据写入不能重复，且提高了索引的效率，使索引更有价值。

---

## 普通索引

- 普通索引就是普通索引 :confused:
- 最好用于 `order by` 、`group by` 、`where column=x` 、`select * from T1 LEFT JOIN T2 ON T1.C1=T2.C2` ，在巧不在多。
- 大量数据添加修改索引时还是建议删掉索引后操作数据，然后再为其添加索引。

---

## 组合索引

- 为多列添加索引，可以使得在多个查询条件的时候匹配更加迅速。
- 组合索引的区分度最好是从大到小，可以第一次索引就筛除大部分数据。
- 要求最左原则。

---


